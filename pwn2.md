# Pwn 2

## Pwn 2

Дизассемблируем файл с помощью Ghidra. Программа читает 500 байт на стек. Можно переписать адрес возврата.  
![image](https://github.com/maximxlss/nto-2024-xls-team/assets/91249047/ba6292fd-b10e-434c-aeba-5fe93ccf37b3)  
Также есть строка `"/bin/bash"`  
![image](https://github.com/maximxlss/nto-2024-xls-team/assets/91249047/ba89f41d-153c-423b-b065-58a2ef599b49)  
И rwx память после функции (с адреса `0x41000` до `0x42000`), большая часть которой - байты `0x00`.
`0x00, 0x00` дизассемблируется как `add [rax], al`. Также по адресу `0x41013` есть гаджет `add byte ptr [rax], al; syscall; ret` и по адресу `0x41018` - `pop rax; ret`.

Переполнив адрес возврата, поместим значение `0x410c3` в регистр rax, затем вызовем гаджет `add byte ptr [rax], al; syscall; ret` (syscall не нужен, но он не мешает) и по адресу `0x410c3` запишем инструкцию `ret`. До неё идёт много байтов `0x00`, которые означают инструкцию `add [rax], al`.

С помощью этого можно модифицировать некоторые байты в памяти и составить необходимый ROP-гаджет. Для этого я написал `genpb.py` и `gennpb.py`. Первый рассчитвает количество раз, которое надо вызвать `add [rax], al` чтобы преобразовать байт из нуля в нужное число (это не всегда возможно, в этом случае возвращается `-1`).

Второй скрипт делает аналогичные операции для 2-х файлов и печатает результаты в формате, подходящем для вставки в Python-код. Аргументы командной строки: `./gennpb.py <target_bytes> <start_addr> <curr_bytes>`.  
`target_bytes` - требуемая последовательность байт (файл) 
`start_addr` - последний байт адреса, с которого начинается запись  
`curr_bytes` - Текущее состояние байт (файл), можно указать `Nulls` если это байты `0x00`.

Напишем код на ассемблере, который загружает значения со стека в регистры rax, rdi, rsi, rdx и переходит по адресу rax:

`sc_shell.nasm`:  
```nasm
BITS 64

pop rax
pop rdi
pop rsi
pop rdx
nop
jmp rax
```

`nop` нужен для того, чтобы было возможно записать данные в память выше описанным способом, а инструкцию `syscall` записать этим способом невозможно, поэтому используется jmp.

При этом инициализируем rax адресом `0x41018`, rdi - адресом строки `"/bin/bash"`, rsi и rdx - нулём. Затем программа перейдёт на `pop rax`, где в rax будет помещено значение 59 (сискол execve) и будет возврат на инструкцию syscall.

Эксплоит находится в `splo.py` (требуется `pwntools`)  
Чаще всего требуется запустить много раз, так как с достаточно большим шансом в используемой rwx-памяти оказывается байт, не равный нулю, из-за этого инструкции записываются некорректно и происходит segfault.
